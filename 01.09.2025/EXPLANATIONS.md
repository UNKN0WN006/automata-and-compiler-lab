# Explanations for programs in 01.09.2025

This document explains the Python programs that build/verify parse trees for simple context-free languages and generate visualization PNGs using Graphviz. Files covered:
- `a2n_bn.py` (L = { a^{2n} b^n | n ≥ 0 })
- `a2n3_bn.py` (L = { a^{2n+3} b^n | n ≥ 0 })
- `an_bn.py` (L = { a^n b^n | n ≥ 0 })
- `equal_a_b.py` (L = { w | #a(w) = #b(w) })

Each section below contains: purpose, high-level idea, step-by-step flow of execution, why certain Python features / libraries were used, sample input/output, complexity notes, and viva tips.

---

**Common notes**
- All programs use `graphviz.Digraph` to build a parse-tree-like graph and save it as a PNG file. This is purely for visualization and demonstration in a viva.
- The programs implement a small recursive backtracking recognizer for the CFGs (except `equal_a_b.py`, which uses a simple count check).
- They are written in a teaching-friendly, explicit style: easy to follow recursion, node creation for visualization, and clear base/termination conditions.

---

**`a2n_bn.py` — Recognizer for L = { a^{2n} b^n | n ≥ 0 }**

Purpose
- Check whether an input string `s` belongs to the language generated by the grammar:
  S → aa S b | ε
  That language generates strings with twice as many `a` as `b`, with all `a`s before all `b`s (i.e., `a^(2n) b^n`).

High-level idea
- The recursive function `check(s, cur, t, par)` maintains a current sentential form `cur` (starting with 'S') and tries to derive `s` by repeatedly replacing the first `S` in `cur` with either `aaSb` or `''` (ε). The function performs depth-first backtracking until it either reaches `s` exactly or can no longer progress.
- While exploring derivations it builds a `Tree` using Graphviz nodes and edges so that, if accepted, you can render the derivation tree as `tree_a2n_bn.png`.

Step-by-step flow
1. Read `s` from stdin.
2. Initialize `Tree` object `t` and root node labeled `S`.
3. Call `check(s, 'S', t, r)` recursively.
   - If current `cur` equals target `s`, return True (a successful derivation).
   - If the length of `cur` without 'S' exceeds `len(s)`, prune (cannot reach `s`).
   - Find first `S` in `cur`:
     - Replace it by `aaSb` and recurse.
     - If that fails, replace it by `''` (ε) and recurse.
   - While recursing, create Graphviz nodes for the expansion used and link them to the parent node so a parse tree is constructed.
4. If any derivation succeeds, print "Accepted" and save the parse tree PNG. Else print "Not Accepted".

Why certain choices / libraries
- `graphviz.Digraph`: lightweight way to produce a parse tree PNG; `render(name, view=False, format='png')` writes a PNG file using Graphviz in the environment.
- `cur.replace('S','')` to estimate current terminal length; it helps pruning branches early to avoid unnecessary recursion.
- Replacing only the first `S` with `.find('S')` mirrors standard leftmost derivation used in many CFG proofs and parse trees.

Complexity
- Backtracking search can be exponential in the worst case; however for short inputs it's fine. The `len(cur.replace('S','')) > len(s)` pruning reduces search significantly.

Viva tips
- Explain grammar and how each rule modifies the count of `a` and `b`: `aaSb` adds two `a`s and one `b` per expansion, matching `a^{2n} b^n`.
- Mention pruning condition and leftmost derivation to justify why search is efficient enough for demo sizes.
- Show an example `s = 'aaaaabb'` → accepted (`n=2`): derivations: S → aaSb → aaaaSbb → aaaaεbb = 'aaaaabb'.

---

**`a2n3_bn.py` — Recognizer for L = { a^{2n+3} b^n | n ≥ 0 }**

Purpose
- Check strings generated by the grammar:
  S → aa S b | aaa
  This yields strings with `2n + 3` `a`s followed by `n` `b`s (n ≥ 0).

High-level idea and differences from `a2n_bn.py`
- Very similar structure and recursive leftmost derivation strategy as `a2n_bn.py`. The base case is `S → aaa` (instead of ε), so derivations always inject at least three `a`s.
- The program builds and renders a parse tree as `tree_a2n3_bn.png` when accepted.

Flow and code notes
- `check` tries `S -> aaSb` then `S -> aaa` (order matches the grammar as written in the file).
- The same pruning condition is used to avoid expanding into strings longer than target `s`.

Why certain choices
- `aaa` base-case ensures minimal length of strings in the language; grammar chosen to model languages like "strings with more `a`s than `b`s in a fixed offset".

Complexity & viva tips
- Same as `a2n_bn.py`: backtracking with pruning; explain base-case change and show a working example.

---

**`an_bn.py` — Recognizer for L = { a^n b^n | n ≥ 0 }**

Purpose
- Check strings of the classic non-regular language (context-free) `a^n b^n` via grammar:
  S → a S b | ε

High-level idea
- Same leftmost derivation recursive recognizer as above. `check` replaces the first `S` with `aSb` or `''`, building a parse tree with Graphviz nodes while exploring.

Flow & code notes
- `check` mirrors standard proof-of-CFG membership: count the `a`s from the left, ensure matching `b`s follow.
- The program will save `tree_an_bn.png` for successful derivations.

Why this implementation is used
- Leftmost expansion gives a natural parse tree and mirrors formal derivations you can draw on paper.
- `ε` base case and pruning help keep search bounded for reasonable inputs.

Viva tips
- This is the canonical CFG for `a^n b^n`. Show that each `a` introduced pairs with a `b` later; explain the derivation tree structure.

---

**`equal_a_b.py` — Recognizer for strings with equal counts of `a` and `b`**

Purpose
- Accept strings where the total number of `a` equals the total number of `b` (order not constrained). Grammar (informal) given:
  S → a S b | b S a | ε
- However the program uses a direct count method rather than recursive derivation.

High-level idea
- Count `a` and `b` with `str.count()` and compare counts; build a small Graphviz tree containing the input string and the counts.

Why this direct approach?
- The language { w | #a(w) = #b(w) } is context-free (it can be generated by the given grammar), but membership can be tested simply by counting symbols. The program chooses clarity and simplicity over illustrating full derivations.
- For visualization the program creates two nodes: one with the string and one with the counts, then links them in the graph.

Complexity
- O(len(s)) for counting; minimal memory overhead.

Viva tips
- Explain that while the grammar with S→aSb|bSa|ε is a correct CFG, the quick count method is valid for membership (counts equal implies grammar can derive the string, though you might want to show constructive derivation in viva for a given string).

---

**Why `graphviz` and this coding style?**
- `graphviz` is used to generate parse tree images. It's educational and helps you visually present derivations in a viva.
- Recursive leftmost derivation mirrors formal proofs and parse trees used in textbooks; the code uses short, explicit recursion to match that reasoning.
- The `pruning` check (`len(cur.replace('S','')) > len(s)`) is used to prevent useless expansions that would exceed the target string length — a small but effective optimization for backtracking recognizers.

**How to run these programs**
- Make sure `graphviz` is installed in the system and the Python `graphviz` package is installed in the environment (pip install graphviz). In a dev container you may also need the Graphviz binary:

```bash
sudo apt-get update && sudo apt-get install -y graphviz
pip install graphviz
```

Then run each file:

```bash
python3 a2n_bn.py
python3 a2n3_bn.py
python3 an_bn.py
python3 equal_a_b.py
```

Each accepted input will produce a PNG in the working directory, e.g., `tree_a2n_bn.png`.

**Viva cheat-sheet (one-liners)**
- "These programs implement leftmost derivations for their CFGs; we build parse trees in Graphviz as we explore derivations."
- "We prune expansions that exceed the target length to keep backtracking practical."
- "`equal_a_b.py` uses counting for simplicity; the corresponding CFG exists and you can show a derivation when needed."

---

If you want, I can:
- Add inline comments to each Python file explaining key lines.
- Convert the recursive recognizers into explicit parsers (e.g., recursive-descent functions that parse the structure without building sentential forms), which is slightly more efficient and closer to production parsing.
- Replace `cur.replace('S','')` pruning with a more precise check (tracking terminals length separately) and update code.

Which of these would you like next?